deepdive {

  db.default {
    driver   : "org.postgresql.Driver"
    url      : "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user     : ${PGUSER}
    password : ${PGPASSWORD}
    dbname   : ${DBNAME}
    host     : ${PGHOST}
    port     : ${PGPORT}
    gphost   : ${GPHOST}
    gpport   : ${GPPORT}
    gppath   : ${GPPATH}
  }

  # Parallel grounding for GreenPlum
  inference.parallel_grounding: ${PARALLEL_GROUNDING}

  # holdout fraction for calibration
  calibration.holdout_fraction: 0.1

  # Execute one extractor at a time (but we use parallelism for extractors)
  extraction.parallelism: 1


  ### PIPELINES ###
  pipeline.run: ${GDD_PIPELINE}
  pipeline.pipelines {
    none: [
    ]
    preprocess: [
      serialize_sentences
    ]
    pheno_candidates: [
      pheno_extract_candidates
    ]
    pheno_candidates: [
      pheno_extract_candidates
    ]
    pheno_features: [
      pheno_extract_features
    ]
    holdout_set: [
      load_genepheno_holdout_set
    ]
    full_pipeline_gp: [
      load_genes,
      uniq_genes,
      load_genepheno_holdout_set,
      gene_extract_candidates, 
      gene_extract_features, 
      pheno_extract_candidates, 
      pheno_extract_features,
      get_genepheno_pairs,
      serialize_genepheno_pairs,
      genepheno_extract_candidates,
      gene_filter_candidates,
      pheno_filter_candidates,
      genepheno_extract_features,
      ensembl_genes,
      # non_gene_acronyms_extract_candidates,
      # non_gene_acronyms_extract_features,
      genepheno_causation_supervision,
      genepheno_association_supervision,
      # variant_extract_candidates,
      # genevariant_extract_candidates,
      gene_inference,
      pheno_inference,
      # genepheno_causation_to_non_gene_acronym,,
      # genepheno_association_to_non_gene_acronym
      genepheno_association_inference,
      genepheno_causation_inference
      # non_gene_acronyms_inference
    ]
    half_pipeline_gp: [
      gene_extract_candidates, 
      gene_extract_features, 
      get_genepheno_pairs,
      serialize_genepheno_pairs,
      genepheno_extract_candidates,
      gene_filter_candidates,
      pheno_filter_candidates,
      genepheno_extract_features,
      ensembl_genes,
      # non_gene_acronyms_extract_candidates,
      # non_gene_acronyms_extract_features,
      genepheno_causation_supervision,
      genepheno_association_supervision,
      # variant_extract_candidates,
      # genevariant_extract_candidates,
      gene_inference,
      pheno_inference,
      # genepheno_causation_to_non_gene_acronym,,
      # genepheno_association_to_non_gene_acronym
      genepheno_association_inference,
      genepheno_causation_inference
      # non_gene_acronyms_inference
    ]
    extractors_gp: [
      gene_extract_candidates, 
      gene_extract_features, 
      pheno_extract_candidates, 
      pheno_extract_features,
      serialize_gene_sentence_mentions,
      serialize_pheno_sentence_mentions,
      genepheno_extract_candidates,
      genepheno_causation_supervisionm,
      genepheno_extract_features
      genepheno_association_supervision,
      get_genepheno_pairs,
      serialize_genepheno_pairs,
      genepheno_extract_candidates,
      gene_filter_candidates,
      pheno_filter_candidates,
      genepheno_extract_features,
      genepheno_causation_supervision,
      genepheno_association_supervision
    ]
    inference_gp: [
      gene_inference,
      pheno_inference,
      genepheno_causation_inference,
      genepheno_causation_to_gene,
      genepheno_causation_to_pheno
      genepheno_association_inference,
      genepheno_association_to_gene,
      genepheno_association_to_pheno
    ]
    postprocess: [
      extract_entity_level_relations
    ]
    variant: [
      variant_extract_candidates
    ]
    variantpheno: [
      variantpheno_extract_candidates,
      variantpheno_extract_features,
      variantpheno_inference
    ]
    genevariant: [
      gene_extract_candidates,
      variant_extract_candidates,
      genevariant_extract_candidates
    ]
    ensembl_genes: [
      ensembl_genes
    ]
    gene_acronyms: [
      gene_acronyms_extract_candidates,
      gene_acronyms_extract_features,
      gene_acronyms_inference
    ]
    non_gene_acronyms: [
      non_gene_acronyms_extract_candidates,
      non_gene_acronyms_extract_features,
      non_gene_acronyms_inference
    ]
    non_gene_acronyms_features: [
      non_gene_acronyms_extract_features
    ]
    non_gene_acronyms_candidates: [
      non_gene_acronyms_extract_candidates
    ]
    non_gene_acronyms_inference: [
      non_gene_acronyms_inference
    ]
  }


### EXTRACTORS ###
  extraction.extractors {

    serialize_sentences: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS sentences_input CASCADE;
        CREATE TABLE 
          sentences_input
        AS SELECT
          doc_id,
          section_id,
          sent_id,
          array_to_string(words, '|^|') AS words,
          array_to_string(lemmas, '|^|') AS lemmas,
          array_to_string(poses, '|^|') AS poses,
          array_to_string(ners, '|^|') AS ners,
          array_to_string(dep_paths, '|^|') AS dep_paths,
          array_to_string(dep_parents, '|^|') AS dep_parents
        FROM
          sentences;
      """
    }

    load_genes: {
      style: tsv_extractor
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} genes
      input: """ SELECT 1, 2, 3 """
      output_relation: genes
      udf: ${APP_HOME}/code/load_ensembl_table.sh
      parallelism: 1
    }

    uniq_genes: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS genes_uniq;
        CREATE TABLE genes_uniq AS (SELECT DISTINCT * FROM genes);
        DROP TABLE IF EXISTS genes;
        ALTER TABLE genes_uniq RENAME TO genes;
      """
      dependencies: [load_genes]
    }

    load_genepheno_holdout_set: {
      style: tsv_extractor
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} genepheno_holdout_set
      input: """ SELECT 1, 2, 3 """
      output_relation: genepheno_holdout_set
      udf: cat ${APP_HOME}/onto/manual/genepheno_holdout_set.tsv
      parallelism: 1
    }

    gene_extract_candidates: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} gene_mentions
      style: tsv_extractor
      input: """
        SELECT
          doc_id,
          section_id,
          sent_id,
          words,
          dep_paths,
          dep_parents,
          lemmas,
          poses,
          ners
        FROM 
          sentences_input
      """
      output_relation: gene_mentions
      udf: ${APP_HOME}/code/gene_extract_candidates.py
      parallelism: ${PARALLELISM}
      dependencies: [serialize_sentences, load_genes]
    }

    gene_extract_features: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} gene_features
      style: tsv_extractor
      input: """
        SELECT 
          s.doc_id,
          s.section_id,
          s.sent_id,
          s.words,
          s.lemmas,
          s.poses,
          s.ners,
          s.dep_paths,
          s.dep_parents,
          m.mention_id,
          m.supertype,
          array_to_string(m.wordidxs, '|^|')
        FROM 
          sentences_input s,
          gene_mentions m
        WHERE 
          s.doc_id = m.doc_id
          AND s.section_id = m.section_id
          AND s.sent_id = m.sent_id
      """
      output_relation: gene_features
      udf: ${APP_HOME}/code/gene_extract_features.py
      parallelism: ${PARALLELISM}
      dependencies: [gene_extract_candidates]
    }

    variant_extract_candidates: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} variant_mentions
      style: tsv_extractor
      input: """
        SELECT
          doc_id,
          section_id,
          sent_id,
          words
        FROM 
          sentences_input
      """
      output_relation: variant_mentions
      udf: ${APP_HOME}/code/variant_extract_candidates.py
      parallelism: ${PARALLELISM}
    }

    # NOTE: input_batch_size extended because Robin thought that the init cost was highest
    # TODO -> re-evaluate this / test..?   
    pheno_extract_candidates: {
      before: ${APP_HOME}/util/pheno_extract_candidates_before.sh
      style: tsv_extractor
      input: """
        SELECT 
          doc_id,
          section_id,
          sent_id,
          words,
          lemmas,
          poses,
          ners
        FROM 
          sentences_input
      """
      output_relation: pheno_mentions
      udf: ${APP_HOME}/code/pheno_extract_candidates.py
      parallelism: ${PARALLELISM}
      input_batch_size: 100000
      dependencies: [serialize_sentences]
    }

    pheno_extract_features: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} pheno_features
      style: tsv_extractor
      input: """
        SELECT 
          s.doc_id,
          s.section_id,
          s.sent_id,
          s.words,
          s.lemmas,
          s.poses,
          s.ners,
          s.dep_paths,
          s.dep_parents,
          m.mention_id,
          array_to_string(m.wordidxs, '|^|')
        FROM 
          sentences_input s,
          pheno_mentions m
        WHERE 
          s.doc_id = m.doc_id 
          AND s.section_id = m.section_id
          AND s.sent_id = m.sent_id
      """
      output_relation: pheno_features
      udf: ${APP_HOME}/code/pheno_extract_features.py
      parallelism: ${PARALLELISM}
      dependencies: [pheno_extract_candidates]
    }
  
    # We first get G-P pairs, then aggregate & serialize them, then do G-P supervision
    # This is to avoide the VMEM error caused by large operations
    # This is also in line with what we will do when we switch to ddlog format
    get_genepheno_pairs: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS genepheno_pairs;
        CREATE TABLE genepheno_pairs AS (
          SELECT
            g.doc_id,
            g.section_id,
            g.sent_id,
            g.mention_id AS gene_mention_id,
            g.gene_name AS gene_name,
            array_to_string(g.wordidxs, '|~|') AS gene_wordidxs,
            g.is_correct AS gene_is_correct,
            p.mention_id AS pheno_mention_id,
            p.entity AS pheno_entity,
            array_to_string(p.wordidxs, '|~|') AS pheno_wordidxs,
            p.is_correct AS pheno_is_correct
          FROM
            gene_mentions g,
            pheno_mentions p
          WHERE
            g.doc_id = p.doc_id
            AND g.section_id = p.section_id
            AND g.sent_id = p.sent_id
        );
      """
      dependencies: [gene_extract_candidates, pheno_extract_candidates]
    }

    serialize_genepheno_pairs: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS genepheno_pairs_sentences;
        CREATE TABLE genepheno_pairs_sentences AS (
          SELECT
            doc_id,
            section_id,
            sent_id,
            array_to_string(ARRAY_AGG(gene_mention_id), '|^|') AS gene_mention_ids,
            ARRAY_AGG(gene_name) AS gene_names,
            array_to_string(ARRAY_AGG(gene_wordidxs), '|^|') AS gene_wordidxs,
            ARRAY_AGG(gene_is_correct) AS gene_is_corrects,
            array_to_string(ARRAY_AGG(pheno_mention_id), '|^|') AS pheno_mention_ids,
            ARRAY_AGG(pheno_entity) AS pheno_entities,
            array_to_string(ARRAY_AGG(pheno_wordidxs), '|^|') AS pheno_wordidxs,
            ARRAY_AGG(pheno_is_correct) AS pheno_is_corrects
          FROM
            genepheno_pairs
          GROUP BY
            doc_id, section_id, sent_id
        );
      """
      dependencies: [get_genepheno_pairs]
    }
    
    non_gene_acronyms_extract_candidates: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} non_gene_acronyms
      style: tsv_extractor
      input: """
        SELECT
          si.doc_id,
          si.section_id,
          si.sent_id,
          si.words,
          si.dep_paths,
          si.dep_parents,
          si.lemmas,
          si.poses,
          si.ners
        FROM 
          sentences_input si
          JOIN (SELECT DISTINCT doc_id FROM gene_mentions) gm
            ON (si.doc_id = gm.doc_id)
        WHERE
          si.words LIKE '%-LRB-%';
      """
      output_relation: non_gene_acronyms
      udf: ${APP_HOME}/code/non_gene_acronyms_extract_candidates.py
      parallelism: ${PARALLELISM}
      dependencies: [serialize_sentences, load_genes, gene_extract_candidates]
    }

    non_gene_acronyms_extract_features: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} non_gene_acronyms_features
      style: tsv_extractor
      input: """
        SELECT 
          s.doc_id,
          s.section_id,
          s.sent_id,
          s.words,
          s.lemmas,
          s.poses,
          s.ners,
          s.dep_paths,
          s.dep_parents,
          m.mention_id,
          m.supertype,
          array_to_string(m.short_wordidxs, '|^|'),
          array_to_string(m.long_wordidxs, '|^|')
        FROM 
          sentences_input s,
          non_gene_acronyms m
        WHERE 
          s.doc_id = m.doc_id
          AND s.section_id = m.section_id
          AND s.sent_id = m.sent_id
      """
      output_relation: non_gene_acronyms_features
      udf: ${APP_HOME}/code/non_gene_acronyms_extract_features.py
      parallelism: ${PARALLELISM}
      dependencies: [non_gene_acronyms_extract_candidates]
    }

    gene_acronyms_extract_candidates: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} gene_acronyms
      style: tsv_extractor
      input: """
        SELECT
          doc_id,
          section_id,
          sent_id,
          words,
          dep_paths,
          dep_parents,
          lemmas,
          poses,
          ners
        FROM 
          sentences_input
        WHERE
          words LIKE '%-LRB-%';
      """
      output_relation: gene_acronyms
      udf: ${APP_HOME}/code/gene_acronyms_extract_candidates.py
      parallelism: ${PARALLELISM}
    }

    gene_acronyms_extract_features: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} gene_acronyms_features
      style: tsv_extractor
      input: """
        SELECT 
          s.doc_id,
          s.section_id,
          s.sent_id,
          s.words,
          s.lemmas,
          s.poses,
          s.ners,
          s.dep_paths,
          s.dep_parents,
          m.mention_id,
          m.supertype,
          array_to_string(m.short_wordidxs, '|^|'),
          array_to_string(m.long_wordidxs, '|^|')
        FROM 
          sentences_input s,
          gene_acronyms m
        WHERE 
          s.doc_id = m.doc_id
          AND s.section_id = m.section_id
          AND s.sent_id = m.sent_id
      """
      output_relation: gene_acronyms_features
      udf: ${APP_HOME}/code/gene_acronyms_extract_features.py
      parallelism: ${PARALLELISM}
      dependencies: [gene_acronyms_extract_candidates]
    }

    genevariant_extract_candidates: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} genevariant_relations
      style: tsv_extractor
      input: """
        SELECT
          s1.doc_id,
          s1.section_id as section1_id,
          s1.sent_id as sent1_id,
          s2.section_id as section2_id,
          s2.sent_id as sent2_id,
          s1.words as words1,
          s1.lemmas lemmas1,
          s1.poses poses1,
          s1.dep_paths dep_paths1,
          s1.dep_parents dep_parents1,
          s2.words as words2,
          s2.lemmas lemmas2,
          s2.poses poses2,
          s2.dep_paths dep_paths2,
          s2.dep_parents dep_parents2,
          g.mention_ids AS gene_mention_ids,
          g.gene_names AS gene_names,
          g.wordidxs AS gene_wordidxs,
          g.is_corrects AS gene_is_corrects,
          v.mention_ids AS variant_mention_ids,
          v.entities AS variant_entities,
          v.wordidxs AS variant_wordidxs,
          v.is_corrects AS variant_is_corrects
        FROM
          sentences_input s1,
          (
            SELECT
              doc_id,
              section_id,
              sent_id,
              array_to_string(ARRAY_AGG(mention_id), '|^|') AS mention_ids,
              ARRAY_AGG(gene_name) AS gene_names,
              array_to_string(ARRAY_AGG(array_to_string(wordidxs, '|^|')), '|~|') AS wordidxs,
              ARRAY_AGG(is_correct) AS is_corrects
            FROM
              gene_mentions
            GROUP BY
              doc_id, section_id, sent_id
          ) g,
          sentences_input s2,
          (
            SELECT
              doc_id,
              section_id,
              sent_id,
              array_to_string(ARRAY_AGG(mention_id), '|^|') AS mention_ids,
              ARRAY_AGG(entity) AS entities,
              array_to_string(ARRAY_AGG(array_to_string(wordidxs, '|^|')), '|~|') AS wordidxs,
              ARRAY_AGG(is_correct) AS is_corrects
            FROM
              variant_mentions
            GROUP BY
              doc_id, section_id, sent_id
          ) v
        WHERE
          s1.doc_id = s2.doc_id
          AND s1.doc_id = g.doc_id
          AND s1.section_id = g.section_id
          AND s1.sent_id = g.sent_id
          AND s2.doc_id = v.doc_id
          AND s2.section_id = v.section_id
          AND s2.sent_id = v.sent_id
      """
      output_relation: genevariant_relations
      udf: ${APP_HOME}/code/genevariant_extract_candidates.py
      parallelism: ${PARALLELISM}
      dependencies: [gene_extract_candidates, variant_extract_candidates]
    }
    
    genepheno_extract_candidates: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} genepheno_relations
      style: tsv_extractor
      input: """
        SELECT
          s.doc_id,
          s.section_id,
          s.sent_id,
          s.words,
          s.lemmas,
          s.poses,
          s.dep_paths,
          s.dep_parents,
          gp.gene_mention_ids AS gene_mention_ids,
          gp.gene_names AS gene_names,
          gp.gene_wordidxs AS gene_wordidxs,
          gp.gene_is_corrects AS gene_is_corrects,
          gp.pheno_mention_ids AS pheno_mention_ids,
          gp.pheno_entities AS pheno_entities,
          gp.pheno_wordidxs AS pheno_wordidxs,
          gp.pheno_is_corrects AS pheno_is_corrects
        FROM
          sentences_input s,
          genepheno_pairs_sentences gp
        WHERE
          s.doc_id = gp.doc_id
          AND s.section_id = gp.section_id
          AND s.sent_id = gp.sent_id
        """
      output_relation: genepheno_relations
      udf: ${APP_HOME}/code/genepheno_extract_candidates.py
      parallelism: ${PARALLELISM}
      dependencies: [serialize_genepheno_pairs]
    }
    
    # Filter candidates that we perform inference on
    gene_filter_candidates: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS gene_mentions_filtered CASCADE;
        CREATE TABLE gene_mentions_filtered AS (
          SELECT DISTINCT
            g.*
          FROM
            gene_mentions g,
            genepheno_relations gp
          WHERE
            g.mention_id = gp.gene_mention_id
        );
      """
      dependencies: [genepheno_extract_candidates]
    }
    
    pheno_filter_candidates: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS pheno_mentions_filtered CASCADE;
        CREATE TABLE pheno_mentions_filtered AS (
          SELECT DISTINCT
            p.*
          FROM
            pheno_mentions p,
            genepheno_relations gp
          WHERE
            p.mention_id = gp.pheno_mention_id
        );
      """
      dependencies: [genepheno_extract_candidates]
    }
    
    genepheno_extract_features: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} genepheno_features
      style: tsv_extractor
      input: """SELECT
              r.relation_id,
              r.doc_id,
              r.section_id,
              r.sent_id,
              r.gene_mention_id,
              r.gene_wordidxs,
              r.pheno_mention_id,
              r.pheno_wordidxs,
              s.words,
              s.lemmas,
              s.poses,
              s.ners,
              s.dep_paths,
              s.dep_parents
           FROM
              genepheno_relations r,
              sentences_input s
          WHERE
              r.doc_id = s.doc_id
              AND r.section_id = s.section_id
              AND r.sent_id = s.sent_id
        """
      output_relation: genepheno_features
      udf: ${APP_HOME}/code/genepheno_extract_features.py
      parallelism: ${PARALLELISM}
      dependencies: [genepheno_extract_candidates]
    }

    genepheno_association_supervision: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} genepheno_association
      style: tsv_extractor
      input: """SELECT 
        r.relation_id,
        r.doc_id,
        r.section_id,
        r.sent_id,
        r.gene_mention_id,
        r.gene_name,
        r.gene_wordidxs,
        r.gene_is_correct,
        r.pheno_mention_id,
        r.pheno_entity,
        r.pheno_wordidxs,
        r.pheno_is_correct,
        s.words,
        s.lemmas,
        s.poses,
        s.dep_paths,
        s.dep_parents
      FROM 
        genepheno_relations r
        join sentences_input s on (r.doc_id = s.doc_id AND r.section_id = s.section_id AND r.sent_id = s.sent_id)
      """
      output_relation: genepheno_association
      udf: ${APP_HOME}/code/genepheno_association_supervision.py
      #parallelism: ${PARALLELISM}
      parallelism: 1
      dependencies: [genepheno_extract_candidates]
    }

    genepheno_causation_supervision: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} genepheno_causation
      style: tsv_extractor
      input: """SELECT 
        r.relation_id,
        r.doc_id,
        r.section_id,
        r.sent_id,
        r.gene_mention_id,
        r.gene_name,
        r.gene_wordidxs,
        r.gene_is_correct,
        r.pheno_mention_id,
        r.pheno_entity,
        r.pheno_wordidxs,
        r.pheno_is_correct,
        s.words,
        s.lemmas,
        s.poses,
        s.dep_paths,
        s.dep_parents
      FROM 
        genepheno_relations r
        join sentences_input s on (r.doc_id = s.doc_id AND r.section_id = s.section_id AND r.sent_id = s.sent_id)
      """
      output_relation: genepheno_causation
      udf: ${APP_HOME}/code/genepheno_causation_supervision.py
      parallelism: ${PARALLELISM}
      dependencies: [genepheno_extract_candidates]
    }

    extract_entity_level_relations: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS genepheno_entity_level;
        CREATE TABLE genepheno_entity_level AS (
          SELECT
            gpa.gene_name AS gene_name,
            gpa.pheno_entity AS pheno_entity,
            ARRAY_AGG(gpa.relation_id) AS relation_ids,
            ARRAY_AGG(gpa.doc_id) AS doc_ids,
            ARRAY_AGG(gpa.section_id) AS section_ids,
            ARRAY_AGG(gpa.sent_id) AS sent_ids,
            ARRAY_AGG(array_to_string(gpa.gene_wordidxs, '|^|')) AS gene_wordidxs,
            ARRAY_AGG(array_to_string(gpa.pheno_wordidxs, '|^|')) AS pheno_wordidxs,
            ARRAY_AGG(si.words) AS words,
            ARRAY_AGG(gpa.expectation) AS a_expectations,
            ARRAY_AGG(gpc.expectation) AS c_expectations,
            MAX(gpa.expectation) AS max_a_expectation,
            MAX(gpc.expectation) AS max_c_expectation
          FROM
            genepheno_association_is_correct_inference gpa,
            genepheno_causation_is_correct_inference gpc,
            sentences_input si
          WHERE
            gpa.relation_id = gpc.relation_id
            AND gpa.doc_id = si.doc_id AND gpa.section_id = si.section_id AND gpa.sent_id = si.sent_id
            AND (gpa.expectation > 0.5 OR gpc.expectation > 0.5)
          GROUP BY
            gpa.gene_name, gpa.pheno_entity
        );
      """
    }

    join_sentences_input_gene_mentions: {
      style: sql_extractor
      sql: """
        DROP TABLE IF EXISTS sentences_input2;
        CREATE TABLE sentences_input2 AS SELECT * FROM sentences_input;
        DROP TABLE sentences_input;
        CREATE TABLE sentences_input AS (
          SELECT distinct si.*
          FROM
            sentences_input2 si
            JOIN gene_mentions gm
             ON (si.doc_id = gm.doc_id AND si.section_id = gm.section_id AND si.sent_id = gm.sent_id)
        );
      """
      dependencies: [gene_extract_candidates]
    }

    variantpheno_extract_candidates: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} variantpheno_relations
      style: tsv_extractor
      input: """
        SELECT
          s.doc_id,
          s.section_id,
          s.sent_id,
          s.words,
          s.lemmas,
          s.poses,
          s.dep_paths,
          s.dep_parents,
          gv.mention_ids AS variant_mention_ids,
          gv.entities AS variant_entities,
          gv.wordidxs AS variant_wordidxs,
          gv.is_corrects AS variant_is_corrects,
          p.mention_ids AS pheno_mention_ids,
          p.entities AS pheno_entities,
          p.wordidxs AS pheno_wordidxs,
          p.is_corrects AS pheno_is_corrects
        FROM
          sentences_input s,
          (
            SELECT
              doc_id,
              section_id,
              sent_id,
              array_to_string(ARRAY_AGG(mention_id), '|^|') AS mention_ids,
              ARRAY_AGG(entity) AS entities,
              array_to_string(ARRAY_AGG(array_to_string(wordidxs, '|^|')), '|~|') AS wordidxs,
              ARRAY_AGG(is_correct) AS is_corrects
            FROM
              variant_mentions
            GROUP BY
              doc_id, section_id, sent_id
          ) gv,
          (
            SELECT
              doc_id,
              section_id,
              sent_id,
              array_to_string(ARRAY_AGG(mention_id), '|^|') AS mention_ids,
              ARRAY_AGG(entity) AS entities,
              array_to_string(ARRAY_AGG(array_to_string(wordidxs, '|^|')), '|~|') AS wordidxs,
              ARRAY_AGG(is_correct) AS is_corrects
            FROM
              pheno_mentions
            GROUP BY
              doc_id, section_id, sent_id
          ) p
        WHERE
          s.doc_id = gv.doc_id
          AND s.section_id = gv.section_id
          AND s.sent_id = gv.sent_id
          AND s.doc_id = p.doc_id
          AND s.section_id = p.section_id
          AND s.sent_id = p.sent_id
        """
      output_relation: variantpheno_relations
      udf: ${APP_HOME}/code/variantpheno_extract_candidates.py
      parallelism: ${PARALLELISM}
      dependencies: [variant_extract_candidates, pheno_extract_candidates]
    }
    
    variantpheno_extract_features: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} variantpheno_features
      style: tsv_extractor
      input: """SELECT
              r.relation_id,
              r.doc_id,
              r.section_id,
              r.sent_id,
              r.variant_mention_id,
              r.variant_wordidxs,
              r.pheno_mention_id,
              r.pheno_wordidxs,
              s.words,
              s.lemmas,
              s.poses,
              s.ners,
              s.dep_paths,
              s.dep_parents
           FROM
              variantpheno_relations r,
              sentences_input s
          WHERE
              r.doc_id = s.doc_id
              AND r.section_id = s.section_id
              AND r.sent_id = s.sent_id
        """
      output_relation: variantpheno_features
      udf: ${APP_HOME}/code/variantpheno_extract_features.py
      parallelism: ${PARALLELISM}
      dependencies: [variantpheno_extract_candidates]
    }
  }


  ### SCHEMA ###

  # Random variables
  schema.variables {
    gene_mentions_filtered.is_correct: Boolean
    pheno_mentions_filtered.is_correct: Boolean
    genepheno_association.is_correct: Boolean
    genepheno_causation.is_correct: Boolean
    # non_gene_acronyms.is_correct: Boolean
    # gene_acronyms.is_correct: Boolean
    # variantpheno_relations.is_correct: Boolean
    # genevariant_relations.is_correct: Boolean
  }


### INFERENCE RULES ###

  # Inference rules
  inference.factors {
    gene_inference {
      input_query = """
        SELECT 
          gm.id as "gene_mentions_filtered.id",
          gm.is_correct as "gene_mentions_filtered.is_correct",
          gf.feature as "gene_features.feature"
        FROM
          gene_mentions_filtered gm,
          gene_features gf
        WHERE 
          gm.mention_id = gf.mention_id;
      """
      function: IsTrue(gene_mentions_filtered.is_correct)
      weight: "?(gene_features.feature)"
    }

    pheno_inference {
      input_query = """
        SELECT 
          pm.id as "pheno_mentions_filtered.id",
          pm.is_correct as "pheno_mentions_filtered.is_correct",
          pf.feature as "pheno_features.feature"
        FROM 
          pheno_mentions_filtered pm, 
          pheno_features pf
        WHERE 
          pm.mention_id = pf.mention_id;
      """
      function: IsTrue(pheno_mentions_filtered.is_correct)
      weight: "?(pheno_features.feature)"
    }

    non_gene_acronyms_inference {
      input_query = """
        SELECT
          nga.id as "non_gene_acronyms.id",
          nga.is_correct as "non_gene_acronyms.is_correct",
          ngaf.feature as "non_gene_acronyms_features.feature"
        FROM
          non_gene_acronyms nga,
          non_gene_acronyms_features ngaf 
        WHERE nga.mention_id = ngaf.mention_id;
      """
      function: IsTrue(non_gene_acronyms.is_correct)
      weight: "?(non_gene_acronyms_features.feature)"
    }

    gene_acronyms_inference {
      input_query = """
        SELECT
          nga.id as "gene_acronyms.id",
          nga.is_correct as "gene_acronyms.is_correct",
          ngaf.feature as "gene_acronyms_features.feature"
        FROM
          gene_acronyms nga,
          gene_acronyms_features ngaf 
         WHERE nga.mention_id = ngaf.mention_id;
      """
      function: IsTrue(gene_acronyms.is_correct)
      weight: "?(gene_acronyms_features.feature)"
    }

    genepheno_association_inference {
      input_query = """
        SELECT 
          gpr.id as "genepheno_association.id",
          gpr.is_correct as "genepheno_association.is_correct",
          gpf.feature as "genepheno_features.feature"
        FROM 
          genepheno_association gpr,
          genepheno_features gpf
        WHERE 
          gpr.relation_id = gpf.relation_id;
      """
      function: IsTrue(genepheno_association.is_correct)
      weight: "?(genepheno_features.feature)"
    }

    genepheno_causation_inference {
      input_query = """
        SELECT 
          gpr.id as "genepheno_causation.id",
          gpr.is_correct as "genepheno_causation.is_correct",
          gpf.feature as "genepheno_features.feature"
        FROM 
          genepheno_causation gpr,
          genepheno_features gpf
        WHERE 
          gpr.relation_id = gpf.relation_id;
      """
      function: IsTrue(genepheno_causation.is_correct)
      weight: "?(genepheno_features.feature)"
    }

    genepheno_association_to_gene {
      input_query: """
        SELECT
          gp.id as "genepheno_association.id",
          gp.is_correct as "genepheno_association.is_correct",
          gm.id as "gene_mentions_filtered.id",
          gm.is_correct as "gene_mentions_filtered.is_correct"
        FROM
          genepheno_association gp,
          gene_mentions_filtered gm
        WHERE
          gp.doc_id = gm.doc_id
          AND gp.section_id = gm.section_id
          AND gp.gene_mention_id = gm.mention_id
        """
      function: "Imply(genepheno_association.is_correct, gene_mentions_filtered.is_correct)"
      weight: "?"
    }

    genepheno_association_to_pheno {
      input_query: """
        SELECT
          gp.id as "genepheno_association.id",
          gp.is_correct as "genepheno_association.is_correct",
          pm.id as "pheno_mentions_filtered.id",
          pm.is_correct as "pheno_mentions_filtered.is_correct"
        FROM
          genepheno_association gp,
          pheno_mentions_filtered pm
        WHERE
          gp.doc_id = pm.doc_id
          AND gp.section_id = pm.section_id
          AND gp.pheno_mention_id = pm.mention_id
        """
      function: "Imply(genepheno_association.is_correct, pheno_mentions_filtered.is_correct)"
      weight: "?"
    }

    genepheno_causation_to_gene {
      input_query: """
        SELECT
          gp.id as "genepheno_causation.id",
          gp.is_correct as "genepheno_causation.is_correct",
          gm.id as "gene_mentions_filtered.id",
          gm.is_correct as "gene_mentions_filtered.is_correct"
        FROM
          genepheno_causation gp,
          gene_mentions_filtered gm
        WHERE
          gp.doc_id = gm.doc_id
          AND gp.section_id = gm.section_id
          AND gp.gene_mention_id = gm.mention_id
        """
      function: "Imply(genepheno_causation.is_correct, gene_mentions_filtered.is_correct)"
      weight: "?"
    }

    genepheno_causation_to_pheno {
      input_query: """
        SELECT
          gp.id as "genepheno_causation.id",
          gp.is_correct as "genepheno_causation.is_correct",
          pm.id as "pheno_mentions_filtered.id",
          pm.is_correct as "pheno_mentions_filtered.is_correct"
        FROM
          genepheno_causation gp,
          pheno_mentions_filtered pm
        WHERE
          gp.doc_id = pm.doc_id
          AND gp.section_id = pm.section_id
          AND gp.pheno_mention_id = pm.mention_id
        """
      function: "Imply(genepheno_causation.is_correct, pheno_mentions_filtered.is_correct)"
      weight: "?"
    }

  }

  # NOTE: the --sample_evidence flag needs the sampler binary from the sample_evidence
  # branch of the sampler repo to be in deepdive/util/; if not, just remove this flag
  sampler.sampler_args: "-l 300 -s 1 -i 500 --alpha 0.1 --diminish 0.99 --sample_evidence"
}

