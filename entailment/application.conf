deepdive {

  db.default {
    driver   : "org.postgresql.Driver"
    url      : "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user     : ${PGUSER}
    password : ${PGPASSWORD}
    dbname   : ${DBNAME}
    host     : ${PGHOST}
    port     : ${PGPORT}
    gphost   : ${GPHOST}
    gpport   : ${GPPORT}
    gppath   : ${GPPATH}
  }

  # Parallel grounding for GreenPlum
  inference.parallel_grounding: ${PARALLEL_GROUNDING}

  # holdout fraction for calibration
#  calibration.holdout_fraction: 0.1
  calibration.holdout_query: """
    INSERT INTO
      dd_graph_variables_holdout(variable_id)
    SELECT
      id
    FROM
      genepheno_facts
    WHERE
      gene NOT IN (select distinct gene from genepheno_cheat)
  """

  # Execute one extractor at a time (but we use parallelism for extractors)
  extraction.parallelism: 1


### PIPELINES ###
  pipeline.run: entailment
  pipeline.pipelines {
    entailment: [
      pheno_pathway_extract,
      pheno_pathway_features,
      genepheno_facts_prior,
      genepheno_cheat,
      pheno_pathway_inference,
      entailment_via_pathways,
      deduction_via_hpo_dag,
      # induction_via_hpo_dag
    ]
  }


### EXTRACTORS ###
  extraction.extractors {
    pheno_pathway_extract: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} pheno_pathway_relations
      style: tsv_extractor
      input: """
        SELECT DISTINCT
          p.child,
          r.pathway_id
        FROM
          reactome_pathways r,
          hpo_dag p
        WHERE
          p.is_pheno
      """
      output_relation: pheno_pathway_relations
      udf: ${APP_HOME}/entailment/src/pheno_pathway_extract.py
      parallelism: ${PARALLELISM}
    }

    pheno_pathway_features: {
      before: ${APP_HOME}/util/truncate_table.sh ${DBNAME} pheno_pathway_features
      style: tsv_extractor
      input: """
        SELECT
          pheno, pathway_id
        FROM
          pheno_pathway_relations
      """
      output_relation: pheno_pathway_features
      udf: ${APP_HOME}/entailment/src/pheno_pathway_features.py
      parallelism: ${PARALLELISM}
      dependencies: [pheno_pathway_extract]
    }
  }


### SCHEMA ###

  # Random variables
  schema.variables {
    genepheno_facts.is_correct: Boolean
    pheno_pathway_relations.is_correct: Boolean
  }


### INFERENCE RULES ###

  # Inference rules
  inference.factors {
    genepheno_facts_prior {
      input_query: """
        SELECT 
          gp.id as "genepheno_facts.id",
          gp.is_correct as "genepheno_facts.is_correct"
        FROM
          genepheno_facts gp
      """
      function: "IsTrue(genepheno_facts.is_correct)"
      weight: "?"
    }

    genepheno_cheat {
      input_query: """
        SELECT
          gp.id as "genepheno_facts.id",
          gp.is_correct as "genepheno_facts.is_correct"
        FROM
          genepheno_facts gp,
          genepheno_cheat gp_cheat
        WHERE
          gp.gene = gp_cheat.gene AND
          gp.pheno = gp_cheat.pheno
        """
      function: "IsTrue(genepheno_facts.is_correct)"
      weight: "?"
    }

    pheno_pathway_inference {
      input_query = """
        SELECT
          pp.id as "pheno_pathway_relations.id",
          pp.is_correct as "pheno_pathway_relations.is_correct",
          f.feature
        FROM pheno_pathway_relations pp, pheno_pathway_features f
        WHERE pp.pheno = f.pheno AND pp.pathway_id = f.pathway_id
        """
      function: "IsTrue(pheno_pathway_relations.is_correct)"
      weight: 10
    }

    entailment_via_pathways {
      input_query: """
        SELECT
          gp1.id as "genepheno_facts.gp1.id",
          gp1.is_correct as "genepheno_facts.gp1.is_correct",
          gp2.id as "genepheno_facts.gp2.id",
          gp2.is_correct as "genepheno_facts.gp2.is_correct",
          pp.id as "pheno_pathway_relations.id",
          pp.is_correct as "pheno_pathways.is_correct"
        FROM
          genepheno_facts gp1,
          genepheno_facts gp2,
          pheno_pathway_relations pp,
          reactome_pathways r1,
          reactome_pathways r2
        WHERE
          gp1.pheno = gp2.pheno AND
          gp1.gene <> gp2.gene AND
          gp1.gene = r1.gene AND
          gp2.gene = r2.gene AND
          r1.pathway_id = r2.pathway_id AND
          pp.pathway_id = r1.pathway_id AND
          pp.pheno = gp1.pheno
      """
      function: "Imply(genepheno_facts.gp1.is_correct, genepheno_facts.gp2.is_correct)"
      weight: 5
    }

    deduction_via_hpo_dag {
      input_query: """
        SELECT
          gp1.id as "genepheno_facts.gp1.id",
          gp1.is_correct as "genepheno_facts.gp1.is_correct",
          gp2.id as "genepheno_facts.gp2.id",
          gp2.is_correct as "genepheno_facts.gp2.is_correct"
        FROM
          genepheno_facts gp1,
          genepheno_facts gp2,
          hpo_dag
        WHERE
          gp1.gene = gp2.gene AND
          gp1.pheno = hpo_dag.parent AND
          gp2.pheno = hpo_dag.child
      """
      function: "Imply(genepheno_facts.gp2.is_correct, genepheno_facts.gp1.is_correct)"
      weight: "?"
    }

    induction_via_hpo_dag {
      input_query: """
        SELECT
          gp1.id as "genepheno_facts.gp1.id",
          gp1.is_correct as "genepheno_facts.gp1.is_correct",
          gp2.id as "genepheno_facts.gp2.id",
          gp2.is_correct as "genepheno_facts.gp2.is_correct"
        FROM
          genepheno_facts gp1,
          genepheno_facts gp2,
          hpo_dag
        WHERE
          gp1.gene = gp2.gene AND
          gp1.pheno = hpo_dag.parent AND
          gp2.pheno = hpo_dag.child
      """
      function: "Imply(genepheno_facts.gp1.is_correct, genepheno_facts.gp2.is_correct)"
      weight: "?"
    }
  }

  sampler.sampler_args: "-l 300 -s 1 -i 500 --alpha 0.1 --diminish 0.99"
}

